#!/bin/bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default options
INCLUDE_PRERELEASE=false
DEBUG=false
INTERACTIVE_UPDATE=false

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -p|--prerelease)
            INCLUDE_PRERELEASE=true
            shift
            ;;
        -d|--debug)
            DEBUG=true
            shift
            ;;
        -u|--update)
            INTERACTIVE_UPDATE=true
            shift
            ;;
        -[a-zA-Z]*)
            # Handle combined short flags like -up, -pd, etc.
            flags="${1#-}"
            shift
            for (( i=0; i<${#flags}; i++ )); do
                flag="${flags:$i:1}"
                case $flag in
                    p)
                        INCLUDE_PRERELEASE=true
                        ;;
                    d)
                        DEBUG=true
                        ;;
                    u)
                        INTERACTIVE_UPDATE=true
                        ;;
                    *)
                        echo "Unknown flag: -$flag"
                        echo "Use --help for usage information"
                        exit 1
                        ;;
                esac
            done
            ;;
        -h|--help)
            echo "Usage: $0 [OPTIONS]"
            echo ""
            echo "Check module versions in solution.yaml against latest versions in blocc registry"
            echo ""
            echo "OPTIONS:"
            echo "  -p, --prerelease    Include pre-release versions in search"
            echo "  -d, --debug         Show debug output"
            echo "  -u, --update        Interactive update mode - prompt to update outdated modules"
            echo "  -h, --help          Show this help message"
            exit 0
            ;;
        *)
            echo "Unknown option $1"
            echo "Use --help for usage information"
            exit 1
            ;;
    esac
done

# Check if solution.yaml exists
if [ ! -f "solution.yaml" ]; then
    echo -e "${RED}Error: solution.yaml not found in current directory${NC}"
    exit 1
fi

# Check if gum is installed when using interactive update
if [ "$INTERACTIVE_UPDATE" = true ]; then
    if ! command -v gum >/dev/null 2>&1; then
        echo -e "${RED}Error: gum is required for interactive update mode${NC}"
        echo -e "${YELLOW}Install gum: https://github.com/charmbracelet/gum#installation${NC}"
        echo -e "${YELLOW}Or use non-interactive mode without --update flag${NC}"
        exit 1
    fi
fi

echo -e "${BLUE}üîç Checking module versions...${NC}\n"

# Function to parse YAML and extract modules
parse_modules() {
    # Extract modules section from solution.yaml using a simpler approach
    python3 -c "
import yaml
import sys

try:
    with open('solution.yaml', 'r') as f:
        data = yaml.safe_load(f)

    if 'spec' in data and 'modules' in data['spec']:
        for alias, config in data['spec']['modules'].items():
            if 'path' in config:
                print(f'{alias}|LOCAL|{config[\"path\"]}|LOCAL')
            elif 'org' in config and 'name' in config and 'version' in config:
                print(f'{alias}|{config[\"org\"]}|{config[\"name\"]}|{config[\"version\"]}')
except Exception as e:
    # Fallback to AWK if Python/PyYAML fails
    sys.exit(1)
" 2>/dev/null || {
        # Fallback AWK implementation with better logic
        awk '
        BEGIN { current_module = "" }
        /^spec:/ { in_spec = 1; next }
        /^  modules:/ && in_spec { in_modules = 1; next }
        /^  [a-zA-Z]/ && in_spec && in_modules { in_modules = 0 }
        /^[a-zA-Z]/ { in_spec = 0; in_modules = 0 }
        in_modules && /^    [a-zA-Z0-9-_]+:$/ {
            # New module found - output previous one if complete
            if (current_module && org && name && version) {
                print current_module "|" org "|" name "|" version
            } else if (current_module && path) {
                print current_module "|LOCAL|" path "|LOCAL"
            }

            # Start new module
            module_name = $1
            gsub(/:$/, "", module_name)
            gsub(/^[ \t]*/, "", module_name)
            current_module = module_name
            org = ""
            name = ""
            version = ""
            path = ""
        }
        in_modules && /^      org:/ {
            org = $2
            gsub(/^[ \t]*/, "", org)
        }
        in_modules && /^      name:/ {
            name = $2
            gsub(/^[ \t]*/, "", name)
        }
        in_modules && /^      version:/ {
            version = $2
            gsub(/^[ \t]*/, "", version)
            gsub(/^"/, "", version)
            gsub(/"$/, "", version)
        }
        in_modules && /^      path:/ {
            path = $2
            gsub(/^[ \t]*/, "", path)
        }
        END {
            # Output the last module
            if (current_module && org && name && version) {
                print current_module "|" org "|" name "|" version
            } else if (current_module && path) {
                print current_module "|LOCAL|" path "|LOCAL"
            }
        }
        ' solution.yaml
    }
}

# Function to get latest version from blocc
get_latest_version() {
    local org=$1
    local module_name=$2

    # Build command with optional prerelease flag
    local cmd="blocc search module $module_name --org $org"
    if [ "$INCLUDE_PRERELEASE" = true ]; then
        cmd="$cmd -p"
    fi

    if [ "$DEBUG" = true ]; then
        echo "  Debug: Running $cmd" >&2
    fi

    # Run blocc search and capture output
    local output=$(eval "$cmd" 2>/dev/null || echo "ERROR")

    if [ "$DEBUG" = true ]; then
        echo "  Debug: Raw output:" >&2
        echo "$output" >&2
        echo "  Debug: End of raw output" >&2
    fi

    if [ "$output" = "ERROR" ]; then
        echo "unknown"
        return
    fi

    # Extract version from the output - look for exact module name match
    local version=$(echo "$output" | awk -v name="$module_name" -v org="$org" '
        /^ Module/ && $0 ~ name && $0 ~ org {
            # Remove leading whitespace and split by multiple spaces/tabs
            gsub(/^[ \t]+/, "")
            n = split($0, fields, /[ \t]+/)
            # fields[1]=Type, fields[2]=Name, fields[3]=Org, fields[4]=Version
            if (fields[2] == name && fields[3] == org) {
                print fields[4]
                exit
            }
        }')

    if [ "$DEBUG" = true ]; then
        echo "  Debug: Extracted version: '$version'" >&2
    fi

    if [ -z "$version" ]; then
        echo "unknown"
    else
        echo "$version"
    fi
}

# Function to compare versions (simplified semver comparison)
compare_versions() {
    local current=$1
    local latest=$2

    # Clean version strings (remove ^ and ~ prefixes)
    current=$(echo "$current" | sed 's/^[\^~]//')

    if [ "$current" = "$latest" ]; then
        echo "current"
    elif [ "$latest" = "unknown" ]; then
        echo "unknown"
    else
        # Use sort -V for version comparison if available
        if command -v sort >/dev/null 2>&1 && sort --version-sort /dev/null >/dev/null 2>&1; then
            local sorted=$(printf "%s\n%s\n" "$current" "$latest" | sort -V)
            local first_line=$(echo "$sorted" | head -1)

            if [ "$first_line" = "$current" ] && [ "$current" != "$latest" ]; then
                echo "outdated"
            elif [ "$first_line" = "$latest" ] && [ "$current" != "$latest" ]; then
                echo "ahead"
            else
                echo "current"
            fi
        else
            # Fallback to string comparison
            if [ "$current" \< "$latest" ]; then
                echo "outdated"
            elif [ "$current" \> "$latest" ]; then
                echo "ahead"
            else
                echo "current"
            fi
        fi
    fi
}

# Main processing
outdated_count=0
results=()

echo -e "${BLUE}üì¶ Processing modules...${NC}\n"

while IFS='|' read -r module_alias org name version; do
    if [ "$org" = "LOCAL" ]; then
        echo -e "‚è≠Ô∏è  Skipping local module: ${module_alias} (path: ${name})"
        continue
    fi

    echo -e "üì¶ Checking ${org}/${name}..."

    latest_version=$(get_latest_version "$org" "$name")
    status=$(compare_versions "$version" "$latest_version")

    results+=("${org}/${name}|${version}|${latest_version}|${status}")

    if [ "$status" = "outdated" ]; then
        ((outdated_count++))
    fi
done < <(parse_modules)

# Display results
echo -e "\n${BLUE}üìä Version Check Results:${NC}"
echo "================================================================================"
printf "%-30s %-15s %-15s %s\n" "Module" "Current" "Latest" "Status"
echo "--------------------------------------------------------------------------------"

for result in "${results[@]}"; do
    IFS='|' read -r module current latest status <<< "$result"

    case $status in
        "current")
            status_display="${GREEN}‚úÖ current${NC}"
            ;;
        "outdated")
            status_display="${YELLOW}‚ö†Ô∏è  outdated${NC}"
            ;;
        "ahead")
            status_display="${BLUE}üöÄ ahead${NC}"
            ;;
        "unknown")
            status_display="${RED}‚ùì unknown${NC}"
            ;;
        *)
            status_display="${RED}‚ùå error${NC}"
            ;;
    esac

    printf "%-30s %-15s %-15s %b\n" "$module" "$current" "$latest" "$status_display"
done

echo "--------------------------------------------------------------------------------"
echo -e "\n${BLUE}üìà Summary: ${outdated_count} modules can be updated${NC}"

if [ $outdated_count -gt 0 ] && [ "$INTERACTIVE_UPDATE" = true ]; then
    echo -e "\n${BLUE}üîß Interactive Update Mode${NC}"
    echo "=============================================="

    # Collect outdated modules for interactive update
    outdated_modules=()
    for result in "${results[@]}"; do
        IFS='|' read -r module current latest status <<< "$result"
        if [ "$status" = "outdated" ]; then
            outdated_modules+=("$module|$current|$latest")
        fi
    done

    if [ ${#outdated_modules[@]} -gt 0 ]; then
        echo -e "\n${YELLOW}Found ${#outdated_modules[@]} outdated modules.${NC}"

        # Create options array for gum choose
        options=()
        module_details=()

        for module_info in "${outdated_modules[@]}"; do
            IFS='|' read -r module current latest <<< "$module_info"
            # Clean version strings for display
            clean_current=$(echo "$current" | sed 's/^[\^~]//')
            clean_latest="$latest"

            option_text="$module ($clean_current ‚Üí $clean_latest)"
            options+=("$option_text")
            module_details+=("$module_info")
        done

        echo -e "\n${BLUE}Select modules to update:${NC}"

        # Use gum choose to select modules
        selected=$(printf '%s\n' "${options[@]}" | gum choose --no-limit --header "Select modules to update (Space to select, Enter to confirm):")

        # Convert selected options back to module info
        updates_to_make=()
        if [ -n "$selected" ]; then
            while IFS= read -r selected_option; do
                for i in "${!options[@]}"; do
                    if [ "${options[$i]}" = "$selected_option" ]; then
                        updates_to_make+=("${module_details[$i]}")
                        break
                    fi
                done
            done <<< "$selected"
        fi

        # Apply updates
        if [ ${#updates_to_make[@]} -gt 0 ]; then
            echo -e "\n${BLUE}üîÑ Applying ${#updates_to_make[@]} updates to solution.yaml...${NC}"

            # Apply each update
            for update in "${updates_to_make[@]}"; do
                IFS='|' read -r module current latest <<< "$update"

                # Extract module alias from the module name (org/name -> get alias from YAML)
                module_alias=""
                while IFS='|' read -r alias org name version; do
                    if [ "$org/$name" = "$module" ]; then
                        module_alias="$alias"
                        break
                    fi
                done < <(parse_modules)

                if [ -n "$module_alias" ]; then
                    # Use Python to reliably update YAML (more precise than sed/awk)
                    python3 -c "
import sys
import re

# Read the file
with open('solution.yaml', 'r') as f:
    content = f.read()

# Find the module section and update the version
module_alias = '$module_alias'
new_version = '^$latest'

# Pattern to match the specific module block and its version line
pattern = rf'(^    {re.escape(module_alias)}:\s*\n(?:      \w+:.*\n)*?      version:\s*)[^\n]+'
replacement = rf'\g<1>\"' + new_version + '\"'

updated_content = re.sub(pattern, replacement, content, flags=re.MULTILINE)

# Write back to file
with open('solution.yaml', 'w') as f:
    f.write(updated_content)

print('Updated successfully')
" || {
                        echo -e "   ${RED}‚úó Python update failed, falling back to sed${NC}"
                        # Fallback to sed (less reliable but works without Python)
                        sed -i.bak "/^    $module_alias:/,/^    [a-zA-Z]/ {
                            /^      version:/ s/version: .*/version: \"^$latest\"/
                        }" solution.yaml
                        rm -f solution.yaml.bak
                    }

                    echo -e "   ${GREEN}‚úì Updated $module_alias: $current -> ^$latest${NC}"
                else
                    echo -e "   ${RED}‚úó Could not find module alias for $module${NC}"
                fi
            done

            echo -e "\n${GREEN}üéâ Updates applied successfully!${NC}"
            echo -e "${YELLOW}üí° Run 'blocc sync' to deploy the updated modules${NC}"
        else
            echo -e "\n${YELLOW}No updates selected.${NC}"
        fi
    fi
elif [ $outdated_count -gt 0 ]; then
    echo -e "\n${YELLOW}üí° To update modules interactively, run: $0 --update${NC}"
    echo -e "${YELLOW}üí° Or edit solution.yaml manually and run: blocc sync${NC}"
fi